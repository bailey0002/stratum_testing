<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Santa Tracker</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1833;
      --panel2:#0c1430;
      --text:#e9f0ff;
      --muted:#9db0d6;
      --accent:#3bd5ff;
      --good:#42f59b;
      --warn:#ffd166;
      --bad:#ff4d6d;
      --grid:rgba(255,255,255,.08);
      --shadow: 0 16px 40px rgba(0,0,0,.35);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1100px 650px at 18% 10%, rgba(59,213,255,.18), transparent 60%),
        radial-gradient(800px 600px at 85% 20%, rgba(66,245,155,.10), transparent 55%),
        radial-gradient(1200px 900px at 50% 100%, rgba(255,77,109,.08), transparent 55%),
        var(--bg);
      color:var(--text);
      min-height:100vh;
      display:flex;
      justify-content:center;
      padding:22px;
    }

    .wrap{
      width:min(1200px, 100%);
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:18px;
    }

    header{
      grid-column:1 / -1;
      display:flex;
      gap:14px;
      align-items:center;
      justify-content:space-between;
      padding:14px 16px;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      backdrop-filter: blur(10px);
    }

    .brand{
      display:flex;
      align-items:center;
      gap:12px;
    }
    .badge{
      width:42px;height:42px;border-radius:14px;
      display:grid;place-items:center;
      border:1px solid rgba(255,255,255,.14);
      background:linear-gradient(135deg, rgba(59,213,255,.24), rgba(255,77,109,.12));
      box-shadow: 0 10px 30px rgba(59,213,255,.12);
      font-size:22px;
    }
    .title{
      display:flex;flex-direction:column;line-height:1.05;
    }
    .title strong{ font-size:18px; letter-spacing:.2px;}
    .title span{ font-size:12px; color:var(--muted); }

    .header-actions{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      justify-content:flex-end;
    }

    .pill{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.12);
      font-family:var(--mono);
      font-size:12px;
      color:var(--text);
      user-select:none;
    }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background:var(--good);
      box-shadow:0 0 18px rgba(66,245,155,.55);
    }

    .btn{
      appearance:none; border:none;
      padding:10px 12px;
      border-radius:12px;
      font-weight:600;
      color:var(--text);
      background:linear-gradient(180deg, rgba(59,213,255,.20), rgba(59,213,255,.08));
      border:1px solid rgba(59,213,255,.28);
      box-shadow:0 10px 26px rgba(59,213,255,.10);
      cursor:pointer;
      transition: transform .08s ease, filter .2s ease;
    }
    .btn:hover{ filter:brightness(1.08); }
    .btn:active{ transform: translateY(1px); }
    .btn.secondary{
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.14);
      box-shadow:none;
    }

    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
      backdrop-filter: blur(10px);
    }

    .mapWrap{
      position:relative;
      height:540px;
      background: radial-gradient(900px 500px at 50% 15%, rgba(59,213,255,.12), transparent 55%),
                  radial-gradient(700px 600px at 30% 90%, rgba(255,77,109,.08), transparent 60%),
                  linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,.22));
    }

    canvas{ display:block; width:100%; height:100%; }

    .mapHUD{
      position:absolute;
      left:14px; right:14px; top:14px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
    }
    .hudCard{
      pointer-events:none;
      width:min(520px, 100%);
      background:rgba(10,16,40,.52);
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      padding:12px 12px;
      box-shadow:0 12px 30px rgba(0,0,0,.25);
    }
    .hudTop{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:baseline;
      margin-bottom:8px;
    }
    .hudTop .label{
      font-size:12px;
      color:var(--muted);
      font-family:var(--mono);
    }
    .hudTop .clock{
      font-size:12px;
      color:var(--muted);
      font-family:var(--mono);
    }
    .hudMain{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .stat{
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      background:rgba(0,0,0,.18);
      padding:10px 10px;
    }
    .stat .k{
      font-size:11px;
      color:var(--muted);
      font-family:var(--mono);
      margin-bottom:6px;
    }
    .stat .v{
      font-size:15px;
      font-weight:700;
      letter-spacing:.2px;
    }
    .stat .sub{
      margin-top:4px;
      font-size:11px;
      color:var(--muted);
      font-family:var(--mono);
    }

    .rightCol{
      display:grid;
      grid-template-rows: auto 1fr;
      gap:18px;
    }

    .info{
      padding:14px 14px;
    }

    .grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
      margin-top:10px;
    }

    .card{
      background:rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:12px;
    }
    .card h3{
      margin:0 0 8px 0;
      font-size:13px;
      color:var(--muted);
      font-family:var(--mono);
      font-weight:600;
      letter-spacing:.2px;
    }
    .big{
      font-size:22px;
      font-weight:800;
      letter-spacing:.2px;
    }
    .mono{ font-family:var(--mono); }
    .muted{ color:var(--muted); }

    .route{
      padding:14px 14px 12px 14px;
    }
    .route h2{
      margin:0 0 10px 0;
      font-size:14px;
      letter-spacing:.2px;
      color:var(--text);
    }
    .list{
      max-height:360px;
      overflow:auto;
      padding-right:6px;
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(0,0,0,.14);
      margin-bottom:8px;
    }
    .row .left{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width:0;
    }
    .row .name{
      font-weight:700;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:260px;
    }
    .row .meta{
      font-size:11px;
      color:var(--muted);
      font-family:var(--mono);
    }
    .row .tag{
      font-size:11px;
      font-family:var(--mono);
      padding:6px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      white-space:nowrap;
    }
    .tag.done{ border-color:rgba(66,245,155,.30); background:rgba(66,245,155,.10); }
    .tag.now{ border-color:rgba(59,213,255,.36); background:rgba(59,213,255,.12); }
    .tag.next{ border-color:rgba(255,209,102,.30); background:rgba(255,209,102,.10); }

    .foot{
      padding:12px 14px 14px 14px;
      border-top:1px solid rgba(255,255,255,.08);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      color:var(--muted);
      font-size:12px;
      font-family:var(--mono);
    }

    @media (max-width: 980px){
      .wrap{ grid-template-columns:1fr; }
      .mapWrap{ height:520px; }
      .row .name{ max-width: 60vw; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="badge">ðŸŽ…</div>
        <div class="title">
          <strong>Santa Tracker</strong>
          <span>Simulated route â€¢ Live stats â€¢ Radar map</span>
        </div>
      </div>
      <div class="header-actions">
        <div class="pill"><span class="dot" id="statusDot"></span><span id="statusText">TRACKING</span></div>
        <button class="btn secondary" id="toggleBtn">Pause</button>
        <button class="btn" id="resetBtn">Reset Route</button>
      </div>
    </header>

    <section class="panel">
      <div class="mapWrap">
        <canvas id="map"></canvas>

        <div class="mapHUD">
          <div class="hudCard">
            <div class="hudTop">
              <div class="label">LIVE TELEMETRY</div>
              <div class="clock" id="clock">--:--:--</div>
            </div>
            <div class="hudMain">
              <div class="stat">
                <div class="k">CURRENT</div>
                <div class="v" id="curCity">â€”</div>
                <div class="sub" id="curCoord">â€”</div>
              </div>
              <div class="stat">
                <div class="k">NEXT STOP</div>
                <div class="v" id="nextCity">â€”</div>
                <div class="sub" id="eta">ETA â€”</div>
              </div>
              <div class="stat">
                <div class="k">SPEED</div>
                <div class="v"><span id="speed">â€”</span> km/s</div>
                <div class="sub">Cruise profile: Aurora</div>
              </div>
              <div class="stat">
                <div class="k">PRESENTS</div>
                <div class="v" id="presents">â€”</div>
                <div class="sub">Delivery mode: Stealth</div>
              </div>
            </div>
          </div>

          <div class="hudCard" style="max-width:320px;">
            <div class="hudTop">
              <div class="label">COUNTDOWN</div>
              <div class="clock mono" id="dateLabel">Dec 25</div>
            </div>
            <div class="stat" style="margin-top:6px;">
              <div class="k">TIME TO MIDNIGHT (LOCAL)</div>
              <div class="v mono" id="countdown">--:--:--</div>
              <div class="sub">Auto-adjusts to your device clock</div>
            </div>
          </div>
        </div>
      </div>

      <div class="foot">
        <div>Map is an abstract projection (lat/long â†’ 2D). Route is simulated.</div>
        <div id="seed" class="mono"></div>
      </div>
    </section>

    <aside class="rightCol">
      <section class="panel info">
        <div class="grid">
          <div class="card">
            <h3>Distance Traveled</h3>
            <div class="big mono"><span id="dist">0</span> km</div>
            <div class="muted mono" id="progress">0% complete</div>
          </div>
          <div class="card">
            <h3>Stops Completed</h3>
            <div class="big mono"><span id="stopsDone">0</span>/<span id="stopsTotal">0</span></div>
            <div class="muted mono" id="region">Global route</div>
          </div>
        </div>
      </section>

      <section class="panel route">
        <h2>Route Manifest</h2>
        <div class="list" id="routeList"></div>
      </section>
    </aside>
  </div>

  <script>
    // ---------- Utility ----------
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const lerp = (a, b, t) => a + (b - a) * t;

    // Great-circle distance (Haversine), in km
    function haversineKm(lat1, lon1, lat2, lon2){
      const R = 6371;
      const toRad = d => d * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const s1 = Math.sin(dLat/2);
      const s2 = Math.sin(dLon/2);
      const a = s1*s1 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*s2*s2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    // Simple seeded RNG
    function mulberry32(seed){
      let t = seed >>> 0;
      return function(){
        t += 0x6D2B79F5;
        let x = Math.imul(t ^ (t >>> 15), 1 | t);
        x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
        return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
      }
    }

    // ---------- Cities ----------
    const CITIES = [
      {name:"North Pole", lat: 90.0000, lon: 0.0000},
      {name:"ReykjavÃ­k, Iceland", lat: 64.1466, lon: -21.9426},
      {name:"London, UK", lat: 51.5072, lon: -0.1276},
      {name:"Paris, France", lat: 48.8566, lon: 2.3522},
      {name:"Rome, Italy", lat: 41.9028, lon: 12.4964},
      {name:"Cairo, Egypt", lat: 30.0444, lon: 31.2357},
      {name:"Nairobi, Kenya", lat: -1.2921, lon: 36.8219},
      {name:"Dubai, UAE", lat: 25.2048, lon: 55.2708},
      {name:"Mumbai, India", lat: 19.0760, lon: 72.8777},
      {name:"Bangkok, Thailand", lat: 13.7563, lon: 100.5018},
      {name:"Singapore", lat: 1.3521, lon: 103.8198},
      {name:"Hong Kong", lat: 22.3193, lon: 114.1694},
      {name:"Tokyo, Japan", lat: 35.6762, lon: 139.6503},
      {name:"Seoul, South Korea", lat: 37.5665, lon: 126.9780},
      {name:"Sydney, Australia", lat: -33.8688, lon: 151.2093},
      {name:"Auckland, New Zealand", lat: -36.8485, lon: 174.7633},
      {name:"Honolulu, USA", lat: 21.3069, lon: -157.8583},
      {name:"San Francisco, USA", lat: 37.7749, lon: -122.4194},
      {name:"Denver, USA", lat: 39.7392, lon: -104.9903},
      {name:"Chicago, USA", lat: 41.8781, lon: -87.6298},
      {name:"New York, USA", lat: 40.7128, lon: -74.0060},
      {name:"Toronto, Canada", lat: 43.6532, lon: -79.3832},
      {name:"Mexico City, Mexico", lat: 19.4326, lon: -99.1332},
      {name:"BogotÃ¡, Colombia", lat: 4.7110, lon: -74.0721},
      {name:"Rio de Janeiro, Brazil", lat: -22.9068, lon: -43.1729},
      {name:"Buenos Aires, Argentina", lat: -34.6037, lon: -58.3816},
      {name:"Cape Town, South Africa", lat: -33.9249, lon: 18.4241},
      {name:"Madrid, Spain", lat: 40.4168, lon: -3.7038},
      {name:"Dublin, Ireland", lat: 53.3498, lon: -6.2603},
      {name:"Oslo, Norway", lat: 59.9139, lon: 10.7522},
    ];

    // ---------- State ----------
    const els = {
      clock: document.getElementById("clock"),
      dateLabel: document.getElementById("dateLabel"),
      countdown: document.getElementById("countdown"),
      curCity: document.getElementById("curCity"),
      nextCity: document.getElementById("nextCity"),
      curCoord: document.getElementById("curCoord"),
      eta: document.getElementById("eta"),
      speed: document.getElementById("speed"),
      presents: document.getElementById("presents"),
      dist: document.getElementById("dist"),
      progress: document.getElementById("progress"),
      stopsDone: document.getElementById("stopsDone"),
      stopsTotal: document.getElementById("stopsTotal"),
      routeList: document.getElementById("routeList"),
      toggleBtn: document.getElementById("toggleBtn"),
      resetBtn: document.getElementById("resetBtn"),
      statusDot: document.getElementById("statusDot"),
      statusText: document.getElementById("statusText"),
      seed: document.getElementById("seed"),
      region: document.getElementById("region"),
    };

    const canvas = document.getElementById("map");
    const ctx = canvas.getContext("2d", { alpha: true });

    const state = {
      running: true,
      seed: (Math.random() * 1e9) | 0,
      rng: null,
      route: [],
      idx: 0,          // current segment start index
      t: 0,            // segment progress 0..1
      segDistKm: 0,
      totalDistKm: 0,
      traveledKm: 0,
      presents: 0,
      lastNow: performance.now(),
      // animation feel
      speedKmPerSec: 28 + Math.random() * 16, // km/s (intentionally playful)
      sweep: 0,
      stars: [],
    };

    function pickRoute(){
      // Create a plausible sweep: start at North Pole, then shuffle the rest.
      state.rng = mulberry32(state.seed);
      const copy = CITIES.slice();
      const np = copy.shift(); // North Pole
      // Shuffle remaining
      for (let i = copy.length - 1; i > 0; i--){
        const j = Math.floor(state.rng() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      // Keep route length reasonable and end at North Pole (optional)
      const len = 18 + Math.floor(state.rng() * 6); // 18..23
      const route = [np, ...copy.slice(0, len - 2), np];

      // Precompute total distance
      let total = 0;
      for (let i = 0; i < route.length - 1; i++){
        total += haversineKm(route[i].lat, route[i].lon, route[i+1].lat, route[i+1].lon);
      }

      state.route = route;
      state.idx = 0;
      state.t = 0;
      state.traveledKm = 0;
      state.totalDistKm = total;
      state.presents = 0;

      // Current segment distance
      state.segDistKm = haversineKm(route[0].lat, route[0].lon, route[1].lat, route[1].lon);

      // Stars
      state.stars = Array.from({length: 140}, () => ({
        x: state.rng(),
        y: state.rng(),
        r: 0.4 + state.rng() * 1.6,
        tw: state.rng() * Math.PI * 2,
        sp: 0.6 + state.rng() * 1.8
      }));

      els.seed.textContent = `seed:${state.seed}`;
      els.stopsTotal.textContent = String(state.route.length);
      els.region.textContent = "Global route";
      renderRouteList();
      updateHUD(true);
    }

    function resize(){
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", () => resize());

    // Map projection: lon [-180..180] -> x, lat [-90..90] -> y (equirectangular)
    function project(lat, lon, w, h){
      const x = ( (lon + 180) / 360 ) * w;
      const y = ( (90 - lat) / 180 ) * h;
      return {x, y};
    }

    function formatCoord(lat, lon){
      const ns = lat >= 0 ? "N" : "S";
      const ew = lon >= 0 ? "E" : "W";
      return `${Math.abs(lat).toFixed(2)}Â°${ns}, ${Math.abs(lon).toFixed(2)}Â°${ew}`;
    }

    function formatInt(n){
      return n.toLocaleString(undefined, {maximumFractionDigits:0});
    }

    function countdownToMidnightLocal(){
      const now = new Date();
      const nextMidnight = new Date(now);
      nextMidnight.setHours(24,0,0,0);
      const ms = Math.max(0, nextMidnight - now);
      const s = Math.floor(ms/1000);
      const hh = String(Math.floor(s/3600)).padStart(2,"0");
      const mm = String(Math.floor((s%3600)/60)).padStart(2,"0");
      const ss = String(s%60).padStart(2,"0");
      return {hh, mm, ss};
    }

    function updateHUD(force=false){
      const route = state.route;
      if (!route.length) return;

      const a = route[state.idx];
      const b = route[Math.min(state.idx + 1, route.length - 1)];

      const lat = lerp(a.lat, b.lat, state.t);
      // wrap longitude interpolation across dateline in a friendly way
      let lonA = a.lon, lonB = b.lon;
      let d = lonB - lonA;
      if (d > 180) lonB -= 360;
      else if (d < -180) lonB += 360;
      const lon = lonA + (lonB - lonA) * state.t;

      const curName = a.name;
      const nextName = b.name;

      els.curCity.textContent = (state.idx === route.length - 1) ? route[route.length-1].name : curName;
      els.nextCity.textContent = (state.idx >= route.length - 1) ? "â€”" : nextName;
      els.curCoord.textContent = formatCoord(lat, ((lon + 540) % 360) - 180);

      // ETA based on remaining in segment
      const remainingKm = (1 - state.t) * state.segDistKm;
      const etaSec = remainingKm / Math.max(1e-6, state.speedKmPerSec);
      const mm = Math.floor(etaSec / 60);
      const ss = Math.floor(etaSec % 60);
      els.eta.textContent = (state.idx >= route.length - 1) ? "Complete" : `ETA ${mm}m ${ss}s`;

      els.speed.textContent = state.speedKmPerSec.toFixed(1);
      els.presents.textContent = formatInt(state.presents);

      els.dist.textContent = formatInt(state.traveledKm);
      const pct = state.totalDistKm > 0 ? (state.traveledKm / state.totalDistKm) * 100 : 0;
      els.progress.textContent = `${pct.toFixed(1)}% complete`;

      els.stopsDone.textContent = String(Math.min(state.idx + (state.t >= 0.999 ? 1 : 0), route.length));
      highlightRoute();

      // Clock + countdown
      const now = new Date();
      els.clock.textContent = now.toLocaleTimeString([], {hour12:false});
      const cd = countdownToMidnightLocal();
      els.countdown.textContent = `${cd.hh}:${cd.mm}:${cd.ss}`;
      els.dateLabel.textContent = now.toLocaleDateString([], {month:"short", day:"2-digit"});
    }

    function renderRouteList(){
      const r = state.route;
      els.routeList.innerHTML = "";
      r.forEach((c, i) => {
        const div = document.createElement("div");
        div.className = "row";
        div.dataset.i = i;

        const left = document.createElement("div");
        left.className = "left";

        const name = document.createElement("div");
        name.className = "name";
        name.textContent = c.name;

        const meta = document.createElement("div");
        meta.className = "meta";
        meta.textContent = formatCoord(c.lat, c.lon);

        left.appendChild(name);
        left.appendChild(meta);

        const tag = document.createElement("div");
        tag.className = "tag";
        tag.textContent = "queued";

        div.appendChild(left);
        div.appendChild(tag);
        els.routeList.appendChild(div);
      });
      highlightRoute();
    }

    function highlightRoute(){
      const rows = els.routeList.querySelectorAll(".row");
      rows.forEach((row) => {
        const i = Number(row.dataset.i);
        const tag = row.querySelector(".tag");
        tag.classList.remove("done","now","next");

        if (i < state.idx){
          tag.textContent = "delivered";
          tag.classList.add("done");
        } else if (i === state.idx){
          tag.textContent = "current";
          tag.classList.add("now");
        } else if (i === state.idx + 1){
          tag.textContent = "next";
          tag.classList.add("next");
        } else {
          tag.textContent = "queued";
        }
      });
    }

    // ---------- Animation + Drawing ----------
    function draw(){
      const rect = canvas.getBoundingClientRect();
      const w = rect.width;
      const h = rect.height;

      ctx.clearRect(0, 0, w, h);

      // Starfield
      for (const s of state.stars){
        s.tw += 0.02 * s.sp;
        const a = 0.35 + 0.25 * Math.sin(s.tw);
        ctx.globalAlpha = a;
        ctx.beginPath();
        ctx.arc(s.x * w, s.y * h, s.r, 0, Math.PI * 2);
        ctx.fillStyle = "white";
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Grid
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      const stepX = w / 12;
      const stepY = h / 8;
      for (let i=1;i<12;i++){
        ctx.moveTo(i*stepX, 0);
        ctx.lineTo(i*stepX, h);
      }
      for (let j=1;j<8;j++){
        ctx.moveTo(0, j*stepY);
        ctx.lineTo(w, j*stepY);
      }
      ctx.stroke();

      // Radar sweep
      const cx = w * 0.5;
      const cy = h * 0.55;
      const r = Math.min(w, h) * 0.55;
      state.sweep += state.running ? 0.012 : 0.0;

      // Sweep cone
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(state.sweep);

      const grad = ctx.createRadialGradient(0,0, 0, 0,0, r);
      grad.addColorStop(0, "rgba(59,213,255,0.22)");
      grad.addColorStop(0.35, "rgba(59,213,255,0.10)");
      grad.addColorStop(1, "rgba(59,213,255,0.0)");

      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0, r, -0.22, 0.22);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // Radar circles
      ctx.strokeStyle = "rgba(59,213,255,0.14)";
      for (let k=1;k<=4;k++){
        ctx.beginPath();
        ctx.arc(cx, cy, (r/4)*k, 0, Math.PI*2);
        ctx.stroke();
      }

      // Route path + points
      const route = state.route;
      if (route.length > 1){
        // Path
        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgba(59,213,255,0.35)";
        ctx.beginPath();
        route.forEach((c, i) => {
          const p = project(c.lat, c.lon, w, h);
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        });
        ctx.stroke();

        // Nodes
        route.forEach((c, i) => {
          const p = project(c.lat, c.lon, w, h);
          const isDone = i < state.idx;
          const isNow = i === state.idx;
          const isNext = i === state.idx+1;

          ctx.beginPath();
          ctx.arc(p.x, p.y, isNow ? 6.5 : (isNext ? 5.5 : 4.0), 0, Math.PI*2);
          ctx.fillStyle = isNow ? "rgba(59,213,255,0.95)"
                      : isNext ? "rgba(255,209,102,0.85)"
                      : isDone ? "rgba(66,245,155,0.75)"
                      : "rgba(255,255,255,0.28)";
          ctx.fill();

          // glow
          if (isNow){
            ctx.beginPath();
            ctx.arc(p.x, p.y, 14, 0, Math.PI*2);
            ctx.fillStyle = "rgba(59,213,255,0.12)";
            ctx.fill();
          }
        });

        // Santa position (interpolated)
        const a = route[state.idx];
        const b = route[Math.min(state.idx + 1, route.length - 1)];
        const lat = lerp(a.lat, b.lat, state.t);
        let lonA = a.lon, lonB = b.lon;
        let d = lonB - lonA;
        if (d > 180) lonB -= 360;
        else if (d < -180) lonB += 360;
        const lon = lonA + (lonB - lonA) * state.t;

        const sp = project(lat, ((lon + 540) % 360) - 180, w, h);

        // Sleigh marker
        ctx.save();
        ctx.translate(sp.x, sp.y);

        // Trail
        ctx.globalAlpha = 0.85;
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,77,109,0.10)";
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.font = "18px " + getComputedStyle(document.body).fontFamily;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("ðŸ›·", 0, 0);

        ctx.restore();
      }
    }

    function tick(now){
      const dt = Math.min(0.05, (now - state.lastNow) / 1000);
      state.lastNow = now;

      if (state.running && state.route.length > 1){
        // Move along segment
        const advance = (state.speedKmPerSec * dt) / Math.max(1e-6, state.segDistKm);
        state.t += advance;

        // Travel accounting
        state.traveledKm += state.speedKmPerSec * dt;

        // Presents ramp (fun simulation)
        // Deliver more near city arrival; also baseline rate
        const pulse = 0.35 + 0.65 * Math.sin((state.idx + state.t) * Math.PI);
        const add = Math.floor( (1200 + 5200 * pulse) * dt );
        state.presents += Math.max(0, add);

        // Segment completion
        while (state.t >= 1 && state.idx < state.route.length - 1){
          state.t -= 1;
          state.idx += 1;

          // At each stop, do a "delivery burst"
          state.presents += Math.floor( 50000 + state.rng()*180000 );

          if (state.idx < state.route.length - 1){
            const a = state.route[state.idx];
            const b = state.route[state.idx+1];
            state.segDistKm = haversineKm(a.lat, a.lon, b.lat, b.lon);

            // slight speed variation per leg
            const base = 26 + state.rng()*18;
            state.speedKmPerSec = base;
          }
        }

        // If finished
        if (state.idx >= state.route.length - 1){
          state.idx = state.route.length - 1;
          state.t = 0;
          state.running = false;
          els.toggleBtn.textContent = "Resume";
          els.statusDot.style.background = "var(--warn)";
          els.statusDot.style.boxShadow = "0 0 18px rgba(255,209,102,.55)";
          els.statusText.textContent = "COMPLETE";
        }
      }

      updateHUD();
      draw();
      requestAnimationFrame(tick);
    }

    // ---------- Controls ----------
    els.toggleBtn.addEventListener("click", () => {
      if (state.idx >= state.route.length - 1){
        // If complete, resume does nothing unless reset
        return;
      }
      state.running = !state.running;
      els.toggleBtn.textContent = state.running ? "Pause" : "Resume";
      els.statusText.textContent = state.running ? "TRACKING" : "PAUSED";
      if (state.running){
        els.statusDot.style.background = "var(--good)";
        els.statusDot.style.boxShadow = "0 0 18px rgba(66,245,155,.55)";
      } else {
        els.statusDot.style.background = "var(--warn)";
        els.statusDot.style.boxShadow = "0 0 18px rgba(255,209,102,.55)";
      }
    });

    els.resetBtn.addEventListener("click", () => {
      // new seed -> new route
      state.seed = ((Math.random() * 1e9) | 0) ^ (Date.now() & 0xffffffff);
      els.statusText.textContent = "TRACKING";
      els.statusDot.style.background = "var(--good)";
      els.statusDot.style.boxShadow = "0 0 18px rgba(66,245,155,.55)";
      state.running = true;
      els.toggleBtn.textContent = "Pause";
      pickRoute();
    });

    // ---------- Init ----------
    resize();
    pickRoute();
    requestAnimationFrame((t) => { state.lastNow = t; tick(t); });
  </script>
</body>
</html>
